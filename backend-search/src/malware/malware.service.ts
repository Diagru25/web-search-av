import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Malware, MalwareDocument } from './malware.schema';
import {
  CreateMalwareDto,
  UpdateMalwareDto,
  SearchMalwareDto,
  PaginatedResponse,
} from './dto/malware.dto';
import { CollectionUnitService } from '../collection-unit/collection-unit.service';

@Injectable()
export class MalwareService {
  constructor(
    @InjectModel(Malware.name) private malwareModel: Model<MalwareDocument>,
    private collectionUnitService: CollectionUnitService,
  ) {}

  async create(
    createMalwareDto: CreateMalwareDto,
    filePath: string,
  ): Promise<Malware> {
    // Validate CollectionUnit exists
    await this.collectionUnitService.findOne(createMalwareDto.collectionUnit);

    // Check if MD5 already exists
    const existingMalware = await this.malwareModel.findOne({
      md5: createMalwareDto.md5,
    });
    if (existingMalware) {
      throw new ConflictException(
        'Malware sample with this MD5 already exists',
      );
    }

    const malware = new this.malwareModel({
      ...createMalwareDto,
      filePath,
      collectionDate: new Date(createMalwareDto.collectionDate),
    });

    const savedMalware = await malware.save();
    const populatedMalware = await this.malwareModel
      .findById(savedMalware._id)
      .populate('collectionUnit')
      .exec();

    if (!populatedMalware) {
      throw new NotFoundException('Failed to retrieve created malware');
    }

    return populatedMalware;
  }

  async findAll(
    pageIndex: number = 1,
    pageSize: number = 10,
  ): Promise<PaginatedResponse<Malware>> {
    const skip = (pageIndex - 1) * pageSize;

    const total = await this.malwareModel.countDocuments();
    const items = await this.malwareModel
      .find()
      .populate('collectionUnit')
      .skip(skip)
      .limit(pageSize)
      .sort({ collectionDate: -1 })
      .exec();

    return {
      items,
      total,
      pageIndex,
      pageSize,
    };
  }

  async findOne(id: string): Promise<Malware> {
    const malware = await this.malwareModel
      .findById(id)
      .populate('collectionUnit')
      .exec();
    if (!malware) {
      throw new NotFoundException('Malware sample not found');
    }
    return malware;
  }

  async findByMd5(md5: string): Promise<Malware> {
    const malware = await this.malwareModel
      .findOne({ md5 })
      .populate('collectionUnit')
      .exec();
    if (!malware) {
      throw new NotFoundException('Malware sample not found');
    }
    return malware;
  }

  async update(
    id: string,
    updateMalwareDto: UpdateMalwareDto,
    newFilePath?: string,
  ): Promise<Malware> {
    // Validate CollectionUnit exists if provided
    if (updateMalwareDto.collectionUnit) {
      await this.collectionUnitService.findOne(updateMalwareDto.collectionUnit);
    }

    const updateData = {
      ...updateMalwareDto,
      ...(updateMalwareDto.collectionDate && {
        collectionDate: new Date(updateMalwareDto.collectionDate),
      }),
      ...(newFilePath && { filePath: newFilePath }),
    };

    const updatedMalware = await this.malwareModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('collectionUnit')
      .exec();

    if (!updatedMalware) {
      throw new NotFoundException('Malware sample not found');
    }

    return updatedMalware;
  }

  async remove(id: string): Promise<void> {
    const result = await this.malwareModel.findByIdAndDelete(id).exec();
    if (!result) {
      throw new NotFoundException('Malware sample not found');
    }
  }

  async search(
    searchDto: SearchMalwareDto,
  ): Promise<PaginatedResponse<Malware>> {
    const query: any = {};

    if (searchDto.sampleName) {
      query.sampleName = new RegExp(searchDto.sampleName, 'i');
    }

    if (searchDto.md5) {
      query.md5 = new RegExp(searchDto.md5, 'i');
    }

    if (searchDto.collectionUnit) {
      query.collectionUnit = searchDto.collectionUnit;
    }

    if (searchDto.fromDate || searchDto.toDate) {
      query.collectionDate = {};
      if (searchDto.fromDate) {
        query.collectionDate.$gte = new Date(searchDto.fromDate);
      }
      if (searchDto.toDate) {
        query.collectionDate.$lte = new Date(searchDto.toDate);
      }
    }

    const pageIndex = searchDto.pageIndex || 1;
    const pageSize = searchDto.pageSize || 10;
    const skip = (pageIndex - 1) * pageSize;

    // Get total count
    const total = await this.malwareModel.countDocuments(query);

    // Get paginated results
    const items = await this.malwareModel
      .find(query)
      .populate('collectionUnit')
      .skip(skip)
      .limit(pageSize)
      .sort({ collectionDate: -1 }) // Sort by collection date, newest first
      .exec();

    return {
      items,
      total,
      pageIndex,
      pageSize,
    };
  }

  async getStatistics(): Promise<any> {
    const total = await this.malwareModel.countDocuments();
    const byUnit = await this.malwareModel.aggregate([
      {
        $group: {
          _id: '$collectionUnit',
          count: { $sum: 1 },
        },
      },
    ]);

    const byMonth = await this.malwareModel.aggregate([
      {
        $group: {
          _id: {
            year: { $year: '$collectionDate' },
            month: { $month: '$collectionDate' },
          },
          count: { $sum: 1 },
        },
      },
      { $sort: { '_id.year': -1, '_id.month': -1 } },
      { $limit: 12 },
    ]);

    return {
      total,
      byUnit,
      byMonth,
    };
  }
}
